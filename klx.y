%{
#include <stdio.h>
#include "symtab.h"
int yylex();
int yyerror(const char *msg);

void set_color(float r, float g, float b) {
   printf("%f %f %f setrgbcolor\n", r, g, b);
}

%}

%token RED ORANGE YELLOW GREEN BLUE PURPLE
%token SQUARE TRIANGLE CIRCLE DIAMOND

%token AT
%token <i> NUMBER
%token <d> DOUBLE

%token SEMICOLON

%token IF ELSEIF ELSE ENDIF
%token WHILE ENDWHILE

%token GT LT EQ GE LE NE

%token EXPONENT
%token MULT DIVIDE MOD
%token PLUS SUBTRACT
%token OPAREN CPAREN
%token COMMA

%token COLEQUAL
%token EQUAL
%token <n> ID

%union { node *n; int i; double d; }

%error-verbose

%%

program: header commands trailer;
header: {
   printf("%%!PS\n\n"
          "%%%% Cameron Taylor\n"
          "%%%% Generated by KLX version 0.0\n\n");
};
trailer: {
   printf("\n%%END\n");
};

commands: ;
commands: command SEMICOLON commands;

code_start: {
   printf("{\n");
};

command: IF bool code_start commands {
   printf("} if\n");
} ENDIF;

command: IF bool code_start commands {
   printf("} {\n");
} ELSE commands {
   printf("} ifelse\n");
} ENDIF;

command: WHILE {
   printf("{ ");
} bool {
   printf(" not { exit } if\n");
} commands {
   printf("} loop\n");
} ENDWHILE;

command: ID COLEQUAL expr {
   $1->defined = 1;
   printf("/klx_%s exch def\n", $1->symbol);
}
command: ID EQUAL expr {
   // set a variable that has been declared
   if (!$1->defined) {
      yyerror("undefined symbol, consider := declaration");
   } else {
      printf("/klx_%s exch def\n", $1->symbol);
   }
};
command: color geometry location {
   printf("klx_func_geom\n"
          "grestore\n");
};

location: AT OPAREN expr COMMA expr CPAREN {
   printf("gsave\n"
          "translate\n");
};

color: RED { set_color(1.0f, 0.0f, 0.0f); };
color: ORANGE { set_color(1.0f, 0.5f, 0.0f); };
color: YELLOW { set_color(1.0f, 1.0f, 0.0f); };
color: GREEN { set_color(0.0f, 1.0f, 0.0f); };
color: BLUE { set_color(0.0f, 0.0f, 1.0f); };
color: PURPLE { set_color(0.5f, 0.0f, 1.0f); };

geometry: SQUARE {
   printf("/klx_func_geom { newpath 0 0 moveto 0 10 lineto 10 10 lineto "
          "10 0 lineto closepath fill } def\n");
};
geometry: TRIANGLE {
   printf("/klx_func_geom { newpath 0 0 moveto 10 0 lineto 5 10 lineto "
          "closepath fill } def\n");
};
geometry: CIRCLE {
   printf("/klx_func_geom { 5 5 5 0 360 arc closepath fill } def\n");
};
geometry: DIAMOND {
   printf("/klx_func_geom { newpath 5 0 moveto 0 5 lineto 5 10 lineto 10 5 "
          "lineto closepath fill } def\n");
};

bool: expr GT expr { printf("gt "); };
bool: expr LT expr { printf("lt "); };
bool: expr EQ expr { printf("eq "); };
bool: expr GE expr { printf("ge "); };
bool: expr LE expr { printf("le "); };
bool: expr NE expr { printf("ne "); };

expr: expr PLUS term { printf("add "); };
expr: expr SUBTRACT term { printf("sub "); };
expr: term;

term: prod EXPONENT term { printf("exp "); };
term: prod;

prod: prod MULT unary { printf("mul "); };
prod: prod DIVIDE unary { printf("div "); };
prod: prod MOD unary { printf("mod "); };
prod: unary;

unary: SUBTRACT atom { printf("neg "); };
unary: PLUS atom;
unary: atom;

atom: NUMBER { printf("%d ", $1); };
atom: DOUBLE { printf("%f ", $1); };
atom: ID {
   if (!$1->defined) {
      yyerror("undefined symbol detected");
   } else {
      printf("klx_%s ", $1->symbol);
   }
};
atom: OPAREN expr CPAREN;

%%

int yyerror(const char *msg) {
   fprintf(stderr, "ERROR: %s\n", msg);
   return 0;
}

int main(void) {
   // yydebug =1;
   yyparse();
   return 0;
}
