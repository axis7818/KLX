%{
#include <stdio.h>
#include "symtab.h"
int yylex();
int yyerror(const char *msg);

void set_color(float r, float g, float b) {
   printf("%f %f %f setrgbcolor\n", r, g, b);
}

%}

%token RED ORANGE YELLOW GREEN BLUE PURPLE
%token SQUARE TRIANGLE CIRCLE DIAMOND

%token AT
%token <i> NUMBER

%token SEMICOLON

%token EXPONENT
%token MULT DIVIDE MOD
%token PLUS SUBTRACT
%token OPAREN CPAREN
%token COMMA

%token EQUAL
%token <n> ID

%union { node *n; int i; double d; }

%error-verbose

%%

program: header commands trailer;
header: {
   printf("%%!PS\n\n"
          "%%%% Cameron Taylor\n"
          "%%%% Generated by KLX version 0.0\n\n");
};
trailer: {
   printf("\n%%END\n");
};

commands: ;
commands: command SEMICOLON commands;

command: ID EQUAL expr {
   printf("/klx_%s exch def\n", $1->symbol);
};
command: color geometry location {
   printf("klx_func_geom\n"
          "grestore\n\n");
};

location: AT OPAREN expr COMMA expr CPAREN {
   printf("gsave\n"
          "translate\n");
};

color: RED {
   set_color(1.0f, 0.0f, 0.0f);
};
color: ORANGE {
   set_color(1.0f, 0.5f, 0.0f);
};
color: YELLOW {
   set_color(1.0f, 1.0f, 0.0f);
};
color: GREEN {
   set_color(0.0f, 1.0f, 0.0f);
};
color: BLUE { set_color(0.0f, 0.0f, 1.0f);
};
color: PURPLE {
   set_color(0.5f, 0.0f, 1.0f);
};

geometry: SQUARE {
   printf("/klx_func_geom { newpath 0 0 moveto 0 10 lineto 10 10 lineto 10 0 lineto closepath fill } def\n");
};
geometry: TRIANGLE {
   printf("/klx_func_geom { newpath 0 0 moveto 10 0 lineto 5 10 lineto closepath fill } def\n");
};
geometry: CIRCLE {
   printf("/klx_func_geom { 5 5 5 0 360 arc closepath fill } def\n");
};
geometry: DIAMOND {
   printf("/klx_func_geom { newpath 5 0 moveto 0 5 lineto 5 10 lineto 10 5 lineto closepath fill } def\n");
};

expr: expr PLUS term {
   printf("add ");
};
expr: expr SUBTRACT term {
   printf("sub ");
};
expr: term;

term: prod EXPONENT term {
   printf("exp ");
};
term: prod;

prod: prod MULT unary {
   printf("mul ");
};
prod: prod DIVIDE unary {
   printf("div ");
};
prod: prod MOD unary {
   printf("mod ");
};
prod: unary;

unary: SUBTRACT atom {
   printf("neg ");
   // printf("-1 mul ");
};
unary: PLUS atom;
unary: atom;

atom: NUMBER {
   printf("%d ", $1);
};
atom: ID {printf("klx_%s ", $1->symbol);};
atom: OPAREN expr CPAREN;

%%

int yyerror(const char *msg) {
   fprintf(stderr, "ERROR: %s\n", msg);
   return 0;
}

int main(void) {
   // yydebug =1;
   yyparse();
   return 0;
}
